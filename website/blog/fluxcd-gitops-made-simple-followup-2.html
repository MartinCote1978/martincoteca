<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>FluxCD GitOps Made Simple: A Follow-up (bis)</title>
    <link href="https://stackpath.bootstrapcdn.com/bootstrap/5.1.3/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta2/css/all.min.css" rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-N5GN1K3DD0"></script>
    <script src="../analytics.js"></script>
</head>

<body>
    <div class="container">
        <div class="back-to-blogs">
            <a href="../blogs.html"><i class="fas fa-arrow-left"></i> Back to Blogs</a>
        </div>

        <article>
            <header class="blog-header">
                <div class="blog-date">October 30, 2025</div>
                <h1 class="blog-title">FluxCD GitOps Made Simple: A Follow-up (bis)</h1>
                <div class="tags">
                    <span class="tag">Kubernetes</span>
                    <span class="tag">GCP</span>
                    <span class="tag">Cloud Native</span>
                    <span class="tag">GitOps</span>
                    <span class="tag">FluxCD</span>
                </div>
            </header>

            <div class="blog-content">
                <p>In my previous posts, <a href="fluxcd-gitops-made-simple.html">"FluxCD GitOps Made Simple: My Journey
                        to Automated Kubernetes Deployments"</a> and its <a
                        href="fluxcd-gitops-made-simple-followup.html">follow-up</a>, I documented my journey from
                    basic FluxCD setup to implementing a layered configuration approach using Git submodules and
                    ConfigMap generation. However, as I continued to scale and improve my GitOps implementation, I
                    encountered
                    significant challenges with Kustomization validation, ConfigMap dependency management, and the
                    complexity of maintaining multiple environment configurations while maximizing the automation I was
                    targeting for. This post details the critical
                    refinements I made to address these issues and achieve a more robust, automated, maintainable GitOps
                    workflow.
                </p>

                <p>The evolution of my FluxCD setup has been driven by the need to solve three core challenges:
                    <strong>Kustomization validation errors</strong> that were preventing proper deployment,
                    <strong>ConfigMap dependency management</strong> that required careful orchestration between
                    component updates and FluxCD reconciliation, and <strong>monitoring and health checks</strong> to
                    ensure the entire system remained in a consistent state. Through this journey, I've learned that
                    while Kustomization is powerful, it demands precise understanding of its validation rules and
                    dependency chains.
                </p>

                <p>My current setup now features a sophisticated <code>configMapGenerator</code> implementation that
                    automatically creates ConfigMaps from component-specific values files stored in Git submodules. This
                    approach ensures that all configuration changes are version-controlled and follow GitOps principles,
                    while the <code>valuesFrom</code> feature in HelmRelease resources allows for layered configuration
                    management across multiple environments. The key breakthrough came when I restructured my repository
                    to separate ConfigMap generation into dedicated Kustomization resources with proper health checks,
                    ensuring that HelmReleases only deploy after their dependent ConfigMaps are successfully created and
                    available.</p>

                <p>This post will walk through the specific changes made to my repository structure, the implementation
                    of proper dependency management, and the lessons learned about Kustomization's validation
                    requirements. I'll also share the monitoring strategies I've implemented to track ConfigMap updates
                    and ensure smooth deployments across both local and sandbox environments.</p>

                <h2>The Problem: Kustomization Validation and Dependency Chaos</h2>
                <p>As my FluxCD implementation grew from a simple setup to a multi-component, multi-environment system,
                    I encountered several critical issues that threatened the reliability of my GitOps workflow:</p>

                <h3>1. Kustomization Validation Errors</h3>
                <p>The most frustrating challenge was Kustomization's strict validation rules. When I initially tried to
                    include <code>configMapGenerator</code> directly in my main environment Kustomization files, I
                    encountered validation errors that prevented deployments. The error messages were often cryptic,
                    pointing to issues with file paths, namespace configurations, or resource references that weren't
                    immediately obvious.</p>

                <h3>2. ConfigMap Dependency Race Conditions</h3>
                <p>Even when ConfigMaps were successfully generated, HelmReleases would sometimes attempt to deploy
                    before their dependent ConfigMaps were fully available in the cluster. This created race conditions
                    where deployments would fail with "ConfigMap not found" errors, requiring manual intervention and
                    reconciliation.</p>

                <h3>3. Complex Update Workflows</h3>
                <p>When component values changed in Git submodules, the update process required multiple manual steps:
                    updating the component repository, pulling changes in the submodule, committing to the main FluxCD
                    repository, and then manually triggering reconciliations. This was error-prone and violated the
                    "automated" principle of GitOps.</p>

                <h3>4. Lack of Visibility</h3>
                <p>Without proper monitoring and health checks, it was difficult to determine whether ConfigMap
                    generation was successful or if dependencies were properly satisfied. This lack of visibility made
                    troubleshooting deployments extremely challenging.</p>

                <h2>The Solution: Restructured Repository with Dedicated Config Management</h2>
                <p>To address these challenges, I completely restructured my FluxCD repository to separate concerns and
                    implement proper dependency management. The key insight was to create dedicated Kustomization
                    resources for ConfigMap generation with explicit health checks and dependency chains.</p>

                <h3>Repository Structure Evolution</h3>
                <p>My current repository structure now follows a clear separation of concerns:</p>

                <pre><code>fluxcdboucio/
├── .gitmodules                    # Git submodule definitions
├── clusters/
│   ├── base/                      # Base configurations
│   │   ├── apps/examples/         # Base HelmRelease definitions
│   │   └── infrastructure/        # Base infrastructure components
│   ├── components/                # Git submodules for each component
│   │   ├── static-website/        # Static website component
│   │   │   ├── base.values.yaml   # Base configuration
│   │   │   ├── lcl.values.yaml    # Local environment values
│   │   │   └── snbx.values.yaml   # Sandbox environment values
│   │   ├── api-java/             # Java API component...
│   │   ├── chatbot-ui/           # Chatbot UI component...
│   │   └── ...                   # Other components
│   ├── local/                     # Local environment
│   │   ├── config/               # ConfigMap generation
│   │   │   └── kustomization.yaml # ConfigMap generators
│   │   ├── apps/examples/        # Local-specific HelmRelease patches
│   │   ├── infrastructure/       # Local infrastructure patches
│   │   ├── flux-system/          # FluxCD system resources
│   │   │   ├── config-kustomization.yaml # Config management
│   │   │   ├── apps-kustomization.yaml   # Apps management
│   │   │   └── infra-kustomization.yaml  # Infrastructure management
│   │   └── kustomization.yaml    # Main local kustomization
│   └── sandbox/                   # Sandbox environment (similar structure)
└── README.md</code></pre>

                <h3>ConfigMap Generation Strategy</h3>
                <p>The core of my solution is the dedicated ConfigMap generation in the <code>config/</code> directory.
                    Here's how it works:</p>

                <pre><code># clusters/local/config/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

configMapGenerator:
  - name: static-web-base-values
    namespace: default
    files:
      - base.values.yaml=../../components/static-website/base.values.yaml
  - name: static-web-level-values
    namespace: default
    files:
      - lcl.values.yaml=../../components/static-website/lcl.values.yaml
  # ... similar entries for all components

generatorOptions:
  disableNameSuffixHash: true

commonLabels:
  config-managed-by: flux</code></pre>

                <h3>Dependency Management with Health Checks</h3>
                <p>The key breakthrough was implementing proper dependency management through FluxCD's
                    <code>dependsOn</code> feature combined with comprehensive health checks:
                </p>

                <pre><code># clusters/local/flux-system/config-kustomization.yaml
apiVersion: kustomize.toolkit.fluxcd.io/v1
kind: Kustomization
metadata:
  name: local-config
  namespace: flux-system
spec:
  interval: 1m
  path: "./clusters/local/config"
  sourceRef:
    kind: GitRepository
    name: flux-system
  prune: true
  timeout: 5m
  force: true # Forces regeneration when component files change

  # Health checks to ensure ConfigMaps are created successfully
  healthChecks:
    - apiVersion: v1
      kind: ConfigMap
      name: static-web-base-values
      namespace: default
    - apiVersion: v1
      kind: ConfigMap
      name: static-web-level-values
      namespace: default
    # ... health checks for all ConfigMaps</code></pre>

                <h3>Apps Dependency on Config</h3>
                <p>Applications are configured to depend on the ConfigMap generation, ensuring proper deployment order:
                </p>

                <pre><code># clusters/local/flux-system/apps-kustomization.yaml
apiVersion: kustomize.toolkit.fluxcd.io/v1
kind: Kustomization
metadata:
  name: local-apps
  namespace: flux-system
spec:
  interval: 1m
  path: "./clusters/local/apps"
  sourceRef:
    kind: GitRepository
    name: flux-system
  prune: true
  timeout: 10m
  
  # THIS IS THE KEY - Apps depend on config
  dependsOn:
    - name: local-config

  # Post-build variable substitution for dynamic values
  postBuild:
    substitute:
      CONFIG_TIMESTAMP: "$(date +%Y%m%d-%H%M%S)"
    substituteFrom:
      - kind: ConfigMap
        name: static-web-base-values
        optional: true
      # ... other ConfigMap references</code></pre>

                <h2>Workflow and Automation</h2>
                <p>The complete workflow now follows a well-defined sequence that ensures reliability and automation:
                </p>

                <h3>1. Component Update Workflow</h3>
                <p>When component values need to be updated:</p>
                <ol>
                    <li><strong>Update Component Repository:</strong> Modify values files in the appropriate Git
                        submodule (e.g., <code>clusters/components/static-website/lcl.values.yaml</code>)</li>
                    <li><strong>Commit and Push:</strong> Commit changes to the component repository</li>
                    <li><strong>Update Submodule:</strong> In the main FluxCD repository, pull the latest changes from
                        the submodule</li>
                    <li><strong>Commit Main Repository:</strong> Commit the submodule update to trigger FluxCD
                        reconciliation</li>
                    <li><strong>Automatic Processing:</strong> FluxCD automatically detects changes and processes them
                        through the dependency chain</li>
                </ol>

                <h3>2. Deployment Sequence</h3>
                <p>The deployment follows this sequence:</p>
                <ol>
                    <li><strong>ConfigMap Generation:</strong> The <code>config-kustomization</code> processes the
                        updated values files and generates new ConfigMaps</li>
                    <li><strong>Health Check Validation:</strong> FluxCD waits for all ConfigMaps to be successfully
                        created and available</li>
                    <li><strong>Application Deployment:</strong> Once ConfigMaps are ready, the
                        <code>apps-kustomization</code> deploys HelmReleases with the updated values
                    </li>
                    <li><strong>Image Automation:</strong> If image tags are updated, the
                        <code>ImageUpdateAutomation</code> commits changes back to the repository
                    </li>
                </ol>

                <h3>3. Monitoring and Observability</h3>
                <p>I've implemented comprehensive monitoring to track the entire process:</p>

                <pre><code># Example HelmRelease with monitoring annotations
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: static-web-helmrelease
  namespace: default
  annotations:
    config-updated: "${CONFIG_TIMESTAMP}" # Tracks when config was last updated
spec:
  interval: 1m
  valuesFrom:
    - kind: ConfigMap
      name: static-web-base-values
      valuesKey: base.values.yaml
    - kind: ConfigMap
      name: static-web-level-values
      valuesKey: lcl.values.yaml
  values:
    image:
      repository: registry.gitlab.com/bouc-io/application/examples/static-website/static-web-example
      tag: "1.0.1825470225" # {"$imagepolicy": "flux-system:static-web-imgpolicy:tag"}</code></pre>

                <h2>Specific Configuration Examples</h2>
                <p>Here are some specific examples from my implementation that demonstrate the layered configuration
                    approach:</p>

                <h3>Base Configuration (Common Across Environments)</h3>
                <pre><code># clusters/components/static-website/base.values.yaml
replicaCount: 1
image:
  pullPolicy: Always
service:
  type: ClusterIP
  port: 80
  targetPort: 80
resources:
  requests:
    cpu: 1m
    memory: 48Mi
autoscaling:
  minReplicas: 1
  maxReplicas: 2
  targetCPUUtilizationPercentage: 80</code></pre>

                <h3>Environment-Specific Overrides</h3>
                <pre><code># clusters/components/static-website/lcl.values.yaml (Local)
image:
  repository: static-web-example
  imagePullSecrets:
environment:
  LOG_LEVEL: "debug"
autoscaling:
  enabled: false</code></pre>

                <pre><code># clusters/components/static-website/snbx.values.yaml (Sandbox)
image:
  repository: registry.gitlab.com/bouc-io/application/examples/static-website/static-web-example
  imagePullSecrets: "gitlab-registry-key"
autoscaling:
  enabled: true</code></pre>

                <h3>Git Submodule Configuration</h3>
                <pre><code># .gitmodules
[submodule "clusters/components/static-website"]
    path = clusters/components/static-website
    url = https://gitlab.com/bouc-io/application/examples/static-website/static-web-chart.git
[submodule "clusters/components/api-java"]
    path = clusters/components/api-java
    url = https://gitlab.com/bouc-io/application/examples/api-sprngbt-example/api-java-chart.git
# ... other components</code></pre>

                <h2>Key Lessons Learned</h2>
                <p>Throughout this journey, I've learned several critical lessons about Kustomization and FluxCD:</p>

                <h3>1. Kustomization Validation is Strict but Predictable</h3>
                <p>Kustomization's validation errors, while initially frustrating, follow consistent patterns. The key
                    is understanding that file paths must be relative to the Kustomization file location, and all
                    referenced resources must exist and be valid Kubernetes resources.</p>

                <h3>2. Dependency Management is Critical</h3>
                <p>Without proper dependency management, race conditions are inevitable. The <code>dependsOn</code>
                    feature combined with health checks ensures that resources are deployed in the correct order.</p>

                <h3>3. Separation of Concerns Improves Maintainability</h3>
                <p>By separating ConfigMap generation from application deployment, the system becomes more modular and
                    easier to understand and modify. Each component has a single responsibility.</p>

                <h3>4. Health Checks Provide Essential Visibility</h3>
                <p>Health checks are not just for validation—they provide crucial visibility into the deployment
                    process. They help identify when and why deployments fail.</p>

                <h3>5. Git Submodules Require Careful Management</h3>
                <p>While Git submodules provide excellent separation of concerns, they require careful management. The
                    update workflow must be well-documented and followed consistently.</p>

                <h2>Monitoring and Troubleshooting</h2>
                <p>I've implemented several monitoring strategies to ensure the system remains healthy:</p>

                <h3>1. FluxCD Status Monitoring</h3>
                <p>Regular monitoring of FluxCD resource status using:</p>
                <pre><code># Check Kustomization status
flux get kustomizations

# Check ConfigMap generation
kubectl get configmaps -n default | grep -E "(base-values|level-values)"

# Check HelmRelease status
flux get helmreleases</code></pre>

                <h3>2. Health Check Validation</h3>
                <p>The health checks in the ConfigMap Kustomization provide immediate feedback when ConfigMap generation
                    fails or succeeds.</p>

                <h3>3. Log Monitoring</h3>
                <p>Monitoring FluxCD controller logs for reconciliation events and errors:</p>
                <pre><code># Monitor kustomize-controller logs
kubectl logs -n flux-system deployment/kustomize-controller -f

# Monitor helm-controller logs
kubectl logs -n flux-system deployment/helm-controller -f</code></pre>

                <h2>Conclusion</h2>
                <p>The journey from a basic FluxCD setup to a sophisticated, multi-component GitOps implementation has
                    been both challenging and rewarding. The key to success was recognizing that Kustomization, while
                    powerful, requires careful attention to validation rules and dependency management.</p>

                <p>The current implementation provides several significant benefits:</p>
                <ul>
                    <li><strong>Reliability:</strong> Proper dependency management eliminates race conditions and
                        ensures consistent deployments</li>
                    <li><strong>Maintainability:</strong> Separation of concerns makes the system easier to understand
                        and modify</li>
                    <li><strong>Scalability:</strong> The modular structure makes it easy to add new components and
                        environments</li>
                    <li><strong>Visibility:</strong> Comprehensive monitoring and health checks provide clear insight
                        into system status</li>
                    <li><strong>Automation:</strong> The complete workflow is automated, reducing manual intervention
                        and human error</li>
                </ul>

                <p>While the initial setup was complex, the resulting system provides a solid foundation for managing
                    Kubernetes deployments across multiple environments with full GitOps compliance. The layered
                    configuration approach with Git submodules and ConfigMap generation has proven to be both flexible
                    and robust.</p>

                <h2>Next Steps</h2>
                <p>Looking forward, I plan to continue evolving this GitOps implementation in several areas:</p>

                <h3>1. Enhanced Secret Management</h3>
                <p>Implement more sophisticated secret management using tools like Sealed Secrets or External Secrets
                    Operator to handle sensitive configuration data while maintaining GitOps principles.</p>

                <h3>2. Infrastructure as Code Integration</h3>
                <p>Extend the GitOps approach to infrastructure components like cert-manager, Istio, and other critical
                    services that are currently managed outside the FluxCD workflow.</p>

                <h3>3. Advanced Monitoring and Alerting</h3>
                <p>Implement more sophisticated monitoring and alerting to detect and respond to deployment issues
                    automatically.</p>

                <h3>4. Multi-Environment Scaling</h3>
                <p>Scale the current approach to support additional environments (staging, production) while maintaining
                    consistency and reducing configuration drift.</p>

                <h3>5. Performance Optimization</h3>
                <p>Optimize the reconciliation intervals and resource usage to improve performance and reduce cluster
                    overhead.</p>

                <p>The foundation is now in place for a robust, scalable GitOps implementation that can grow with my
                    needs while maintaining the principles of declarative configuration, version control, and automated
                    deployment.</p>

                <h2>References and Further Reading</h2>
                <p>This implementation builds upon several key resources and best practices:</p>
                <ul>
                    <li><a href="https://fluxcd.io/flux/guides/repository-structure/" target="_blank">FluxCD Repository
                            Structure Guide</a> - Official best practices for organizing FluxCD repositories</li>
                    <li><a href="https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/configmapgenerator/"
                            target="_blank">Kustomize configMapGenerator Documentation</a> - Detailed guide for
                        ConfigMap generation</li>
                    <li><a href="https://fluxcd.io/flux/components/helm/helmreleases/#values-from"
                            target="_blank">FluxCD HelmRelease valuesFrom Documentation</a> - Official documentation for
                        layered configuration</li>
                    <li><a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules" target="_blank">Git Submodules
                            Guide</a> - Comprehensive documentation on Git submodules</li>
                    <li><a href="https://github.com/fluxcd/flux2-kustomize-helm-example" target="_blank">FluxCD
                            Kustomize Helm Example</a> - Official example demonstrating Kustomize integration</li>
                </ul>

                <p><i>This blog post represents the culmination of months of experimentation and refinement in GitOps
                        practices. The lessons learned here should help others avoid similar challenges and build more
                        robust Kubernetes deployment workflows.</i></p>

            </div>
        </article>

        <div class="d-flex justify-content-center vertical-spacing">
            <a href="https://github.com/MartinCote1978" class="social-link" target="_blank">
                <i class="fab fa-github social-icon"></i>
            </a>
            <a href="https://www.linkedin.com/in/martincote" class="social-link" target="_blank">
                <i class="fab fa-linkedin-in social-icon"></i>
            </a>
            <a href="https://mastodon.online/@MartinCote" class="social-link" target="_blank">
                <i class="fab fa-mastodon social-icon"></i>
            </a>
            <a href="https://gitlab.com/bouc-io" class="social-link" target="_blank">
                <i class="fab fa-gitlab social-icon"></i>
            </a>
        </div>
    </div>

    <script src="https://stackpath.bootstrapcdn.com/bootstrap/5.1.3/js/bootstrap.min.js"></script>
    <script>
        // Dynamically load the social links block
        fetch('social-links.html')
            .then(response => response.text())
            .then(data => {
                document.getElementById('social-links').innerHTML = data;
            });
    </script>
</body>

</html>